-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- la TDS courante
inh tds_asm : TDS for ASM;

inh tds : TDS for ENTITES, DECL, ENTITE, INST, INSTS, STYPE, BLOC, SIX, E, F, TX, T, R, RX, A, AX, AFFX;
syn type : DTYPE for TYPE, PARF, CHAMP, STYPE, E,AX,AFFX,R,RX,T,POADD,TX,OPMUL,F,OPUN,OPADD, FX, A; 
inh htype : DTYPE for DECL, PTRS;
inh champs : LCHAMPS for CHAMPS, CHAMP ; --liste des champs
syn champ : CHAMP for CHAMP; 
inh hadr : INTEGER for BLOC, INSTS, INST , CHAMPS, CHAMP; 
--syn est_variable : BOOLEAN for DECL,ENTITE;
--syn est_fonction : BOOLEAN for DECL,ENTITE;
--inh hest_variable : BOOLEAN for ENTITE;
--inh hest_fonction : BOOLEAN for ENTITE;
--inh hlistparam : PARAMLIST for DECL, FONCTION, PARFS, PARFSX;
--syn listparam : PARAMLIST for FONCTION;
inh hinfofonction : INFOFONCTION for FONCTION, PARFS, PARFSX ; 
inh htxt : STRING for DECL;
syn adr : INTEGER for INSTS, INST;


--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

--production rules
PROGRAMME -> #init ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
  tds : TDS;
do
   tds := new TDS();
   ENTITES^tds := tds;
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}
-- ecrit le code dans un fichier
#gen {
local
do
   machine.writeCode(PROGRAMME^source.getFileName(),"; no code\n");  
end
}
ENTITES -> ;
ENTITES -> #gen ENTITE ENTITES;

#gen {
local
do
    --ENTITE^hest_variable := false;
    --ENTITE^hest_fonction := false;
    
end
}


-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc #tdstype pv ;

#tdstype {
local
  i : INFOTYPE;
do
  i := new INFOTYPE(new DTYPE(identc^txt,TYPE^type.getTaille()));
  ENTITE^tds.inserer(identc^txt,i);
end
}
-- definition d'une variable globale ou d'une fonction
-- (commence par une minuscule)

ENTITE ->  TYPE ident #tdsglob DECL ;

#tdsglob {
local
do
  DECL^htype := TYPE^type;
  DECL^htxt := ident^txt;
end
}
-- Variable
DECL -> pv #typeinfo;

#typeinfo {
local 
    i : INFOVAR;
do
  
  i := new INFOVAR(new DTYPE(DECL^htype.getNom(),DECL^htype.getTaille()),0);
  DECL^tds.inserer(DECL^htxt,i);
  
end
}
DECL -> #typeinfo FONCTION  ;

#typeinfo {
local
    i : INFONCTION;
do
  
    i := new INFOVAR(new DTYPE(DECL^htype.getNom(),DECL^htype.getTaille()),0);
    DECL^tds.inserer(DECL^htxt,i);
    FONCTION^hinfofonction:=i;
    
end
}
-- Fonction
FONCTION ->  paro PARFS parf BLOC ;


-- parametres de fonctions
PARFS ->  ;
PARFS ->  PARF #majliste PARFSX;

#majliste {
local
do

  PARFS^hinfofonction.ajouter(PARF^type); 

end
}

PARFSX -> ;



PARFSX ->  virg PARF #majliste PARFSX ;

#majliste {
local
do

  PARFSX^hinfofonction.ajouter(PARF^type);

end
}

PARF ->  TYPE ident #typeparam;

#typeparam {
local
do

  PARF^type := TYPE^type;
  
end
}

-- les types (de base, noms, struct et pointeurs)
TYPE -> STYPE #ptype  PTRS #type;

#type {
local
do

  TYPE^type :=  STYPE^type;

end
}

#ptype {
local
do

    PTRS^htype:=STYPE^type;

end
}


-- type de base
-- des * pour definir un pointeur
PTRS -> ;
PTRS -> mult PTRS ;
-- types de base
STYPE-> void #type ;

#type {
local
do

  STYPE^type := new DTYPE("void",0);
  
end
}

STYPE-> int #type ;

#type {
local
do

  STYPE^type := new DTYPE("entier",4);
  
end
}

STYPE-> char #type ;

#type {
local
do

  STYPE^type := new DTYPE("caractere",1);
  
end
}

-- nom de type (commence par une majuscule)
STYPE -> identc #type;
#type {
local
  i : INFO ;
  it : INFOTYPE ;
  t : DTYPE ;
do
  i := STYPE^tds.chercherGlobalement(identc^txt) ;
  if i = nil then
    error(B_01, identc^txt) ;
  else
    match i
    with INFOTYPE then
      it := i;
      STYPE^type := it.getType();
    else
      error(B_07,identc^txt);
    end
  end
end
}
  
-------------  
-- et struct
STYPE -> struct aco #ch CHAMPS acf #type ;
global
lc : LCHAMPS ;

#ch {
do
  lc := new LCHAMPS() ;
  CHAMPS^champs := lc ;
  CHAMPS^hadr := 0 ;
end
}

#type {
do
  STYPE^type := new STRUCT(lc) ; 
end
} 
CHAMPS -> ;
-- un nom de champ commence par une minuscule
CHAMPS -> #chh CHAMP #ch CHAMPS ;
#chh {
do
  CHAMP^hadr := CHAMPS^hadr ;
  CHAMP^champs := CHAMPS^champs; 
end
} 

#ch {
do
  call CHAMPS^champs.inserer(CHAMP^champ) ; 
  CHAMPS1^hadr := CHAMPS^hadr + CHAMP^type.getTaille();
end
}

  
CHAMP -> TYPE ident pv #ch; 
#ch {
local
c : CHAMP ;
do
  c := CHAMP^champs.chercher(ident^txt) ;
  if c /= nil then
    error(B_00, ident^txt) ;
  else 
    c := new CHAMP(ident^txt, TYPE^type, CHAMP^hadr) ;
    CHAMP^champ := c; 
    CHAMP^type := TYPE^type ;  
  end
     
end
}
-- corps de fonction et bloc d'instructions
BLOC ->  aco INSTS acf ;
-- instructions
INSTS ->  #gen ;

#gen {
local
do

  INSTS^adr := INSTS^hadr;

end
}

INSTS ->  INST #calcadresse INSTS #gen ;

#calcadresse {
local
do

  INSTS1^hadr := INST^adr;

end
}

#gen {
local
do

  INSTS^adr := INSTS1^adr;

end
}

-- declaration de variable locale avec ou sans init 
INST ->  TYPE ident AFFX pv #gen;

#gen {
local
  i : INFO;
do

  i := INST^tds.chercherLocalement(ident^txt);
  if i /= null then
    error(VAR_EXISTANTE,ident^txt);
  else
     i := new INFOVAR(TYPE^type,INST^hadr);
     INST^tds.inserer(ident^txt,i);
     INST^adr := INST^hadr + TYPE^type.getTaille();
  end

end
}
-- instruction expression (affectation et appel de procedure)
INST -> E pv #calcadr;

#calcadr {
local
do

  INST^adr := INST^hadr;
  
end
}

-- bloc d'instructions
INST ->  BLOC  ;
-- conditionnelle
INST ->   si paro E #type parf BLOC SIX #gen;

#gen {
local
do

  INST^adr := INST^hadr;
  
end
}

#type {
local
do

  if ~E^type.compareTo(new DTYPE("booleen",1)) then
    error(MAUVAIS_TYPAGE_COND,E^type);
  end

end
}
SIX ->    sinon BLOC ;
SIX -> ;
-- retour de fonction
INST ->  retour  E pv #calcadresse ;

#calcadresse {
local
do

  INST^adr := INST^hadr;

end
}


-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------
E ->   A  AFFX #type;

#type {
local
do

  if AFFX^type.getNom() = "void" then
    E^type := A^type;
  else 
    E^type := new DTYPE("booleen",'1');
  end

end
}
-- affectation
AFFX -> affect  A #type ;

#type {
local
do

  AFFX^type := A^type;

end
}

AFFX -> #type ;

#type {
local
do

  AFFX^type := new DTYPE("void",0);
  
end
}

-- relation
A ->   R AX #type ;

#type {
local
do

  if AX^type.getNom()="void" then
    A^type := R^type;
  else
    A^type := AX^type;
  end
  
end
}

AX -> OPREL R #type;

#type {
local
do

  AX^type := new DTYPE("booleen",1);

end
}
AX -> #type ;

#type {
local
do

  AX^type := new DTYPE("void",0);

end
}
-- operateurs relationnels
OPREL -> inf ;
OPREL -> sup ;
OPREL -> infeg ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;
R ->  T  RX #type ;

#type {
local
do

  if RX^type.getNom()="void" then
    R^type := T^type;
  else if T^type /= RX^type then
         error(ERREUR_TYPAGE_OPERATION,T^type,RX^type);
       else
         R^type := T^type;
       end
  end

end
}
-- additions ...
RX ->   OPADD  T RX #type ;

#type {
local
do

  if OPADD^type.getNom()="booleen" then
    RX^type := OPADD^type;
  else if T^type /= RX1^type then
          error(ERREUR_TYPAGE_OPERATION,T^type,RX1^type);
       else
          RX^type := T^type;
       end
  end
          

end
}
RX -> #type;

#type {
local
do

  RX^type := new DTYPE("void",0);

end
}
-- operateurs additifs
OPADD -> plus #type;

#type {
local
do

  OPADD^type := null;

end
}
OPADD -> moins #type ;

#type {
local
do

  OPADD^type := null;

end
}
OPADD -> ou #type;

#type {
local
do

  OPADD^type := new DTYPE("booleen",1);

end
}
-- multiplication, ...
T ->  F  TX #type ;

#type {
local
do

  if TX^type.getNom()="void" then 
    T^type := F^type;
  else if F^type/=TX^type then
         error(ERREUR_TYPAGE_OPERATION,F^type,TX^type);
       else
         T^type := F^type;
       end
  end

end
}
TX ->   OPMUL  F TX  #type;

#type {
local
do

  if OPMUL^type.getNom()="booleen" then
    TX^type := OPMUL^type;
  else if F^type/=TX1^type then
         error(ERREUR_TYPAGE_OPERATION,F^type,TX1^type);
       else 
         TX^type := F^type;
       end
  end

end
}

TX -> #type ;

#type {
local
do

  TX^type := new DTYPE("void",0);

end
}
-- operateurs multiplicatifs
OPMUL -> mult #type;

#type {
local
do

  OPMUL^type := null;
  
end
}
OPMUL -> div #type;

#type {
local
do

  OPMUL^type := null;
  
end
}
OPMUL -> mod #type; 

#type {
local
do

  OPMUL^type := null;
  
end
}
OPMUL -> et #type;

#type {
local
do

  OPMUL^type := new DTYPE("booleen",1);
  
end
}
-- expressions de base
-- Constante entiere
F -> entier #type  ;

#type {
local
do

  F^type := new DTYPE("entier",1);

end
}
-- Constante chaine
F -> chaine #type;

#type {
local
do

  F^type := new DTYPE("chaine",0);

end
}
-- Constante caractere
F -> caractere #type;

#type {
local
do

  F^type := new DTYPE("caractere",1);
  
end
}
-- expression unaire
F ->  OPUN  F #type ;

#type {
local
do

  if OPUN^type.getNom() = "booleen" then if F1^type.getNom()/="booleen" then
                                            error(NON_BOOLEEN,F1^type);
                                         else
                                            F^type := OPUN^type;
                                         end
                                    else 
                                         F^type := F1^type;
                                    end
                                    

end
}
-- operateurs unaires
OPUN -> plus #type ;

#type {
local
do

  OPUN^type := null;

end
}
OPUN -> moins #type ;

#type {
local
do

  OPUN^type := null;

end
}

OPUN -> non #type;

#type {
local
do

  OPUN^type := new DTYPE("booleen",1);

end
}

-- pointeur NULL
F -> null #type ;

#type {
local
do

  F^type := null;
  
end
}
-- expression parenthesee
F ->  paro E parf FX #type;

#type {
local
do

  if FX^type.getNom()="void" then
    F^type := E^type;
  else
    --a faire
    F^type := null;
  end

end
}
F ->  paro TYPE parf  F #type;

#type {
local
do

  if TYPE^type/=F1^type then
    error(ERREUR_TYPAGE,TYPE^type,F1^type);
  else
    F^type := TYPE^type;
  end

end
}
F -> mult F #type ;

#type {
local
do

  F^type := F1^type;
  
end
}

F -> ident #tds FX #type ;

#tds {
local
do

  call F^tds.inserer(ident^txt,new INFOVAR(new DTYPE("entier",1),0));

end
}

#type {
local
do

  F^type := FX^type;

end
}

FX -> #type;

#type {
local
do

  FX^type := new DTYPE("void",0);

end
}
-- acces champ
FX ->   pt  ident FX ;
-- acces champ pointeur
FX ->   arrow  ident FX ;
-- appel de sous-programme
FX ->   paro ES parf FX;
-- arguments appel de sous-programme
ES -> ;
ES -> E ESX  ;
ESX ->  ;
ESX -> virg E ESX ;

------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur TAM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := null; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end